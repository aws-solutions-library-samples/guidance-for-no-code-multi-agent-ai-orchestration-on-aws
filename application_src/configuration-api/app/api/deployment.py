"""
Stack deployment API endpoints.

This module provides endpoints for dynamic agent stack deployment using CloudFormation,
allowing users to create new agent instances via Config API triggers.
"""

import logging
import json
from typing import Dict, Any, Optional
from datetime import datetime

from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends, Body
from pydantic import BaseModel, Field

from app.services.deployment_service import DeploymentService
from app.services.agent_config_service import AgentConfigService
from app.utils.dependencies import get_deployment_service, get_agent_config_service
from app.models import AgentConfigRequest

# Authentication middleware imports
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../../../'))

from common.auth import UserInfo
from ..middleware.auth_middleware import get_current_user, RequirePermission
from common.secure_logging_utils import SecureLogger, log_exception_safely

logger = logging.getLogger(__name__)

# Create the router - using /api/deployment for UI compatibility
deployment_router = APIRouter(prefix="/api/deployment")


class DeployAgentRequest(BaseModel):
    """Request model for deploying a new agent stack via CloudFormation."""
    agent_name: str = Field(..., description="Name of the agent to deploy")
    parameters: Dict[str, Any] = Field(default_factory=dict, description="CloudFormation parameters")
    timeout_minutes: int = Field(default=30, description="Deployment timeout in minutes")


class DeployAgentResponse(BaseModel):
    """Response model for agent stack deployment."""
    stack_name: str = Field(..., description="Name of the deployed stack")
    agent_name: str = Field(..., description="Agent name used in the stack")
    status: str = Field(..., description="Deployment status")
    outputs: Dict[str, Any] = Field(default_factory=dict, description="Stack outputs")
    deployed_at: Optional[str] = Field(None, description="Deployment timestamp")


class StackStatusResponse(BaseModel):
    """Response model for stack status."""
    stack_name: str = Field(..., description="Name of the stack")
    stack_id: Optional[str] = Field(None, description="CloudFormation stack ID")
    status: str = Field(..., description="Current stack status")
    creation_time: Optional[str] = Field(None, description="Stack creation timestamp")
    last_updated_time: Optional[str] = Field(None, description="Last update timestamp")
    outputs: Dict[str, Any] = Field(default_factory=dict, description="Stack outputs")


@deployment_router.post("/deploy-agent", response_model=DeployAgentResponse)
async def deploy_agent_stack(
    request: DeployAgentRequest,
    background_tasks: BackgroundTasks,
    current_user: UserInfo = Depends(get_current_user),
    _: None = Depends(RequirePermission("agent:deploy")),
    deployment_service: DeploymentService = Depends(get_deployment_service)
):
    """
    Deploy a new agent stack using CloudFormation API.
    
    This endpoint triggers CloudFormation stack creation using templates from S3.
    The template is auto-generated by app-template-generator.py during CDK synthesis.
    
    The deployment process:
    1. Downloads CloudFormation template from S3
    2. Creates stack with provided parameters
    3. Monitors deployment progress
    4. Returns deployment status and outputs
    
    Args:
        request: Deployment request parameters
        background_tasks: FastAPI background tasks for async operations
        cfn_service: Injected CloudFormation deployment service
        
    Returns:
        Deployment information including stack name, status, and outputs
        
    Raises:
        HTTPException: If deployment fails
    """
    try:
        logger.info(f"Deploying agent stack for agent: {request.agent_name}")
        
        # Validate agent name format
        if not request.agent_name.replace('_', '').replace('-', '').isalnum():
            raise HTTPException(
                status_code=400,
                detail="Agent name must contain only letters, numbers, underscores, and hyphens"
            )
        
        # Deploy the stack using CloudFormation template from S3
        # Use consistent naming pattern throughout all operations
        new_stack_name = deployment_service.get_stack_name_from_agent(request.agent_name)
        
        result = await deployment_service.create_agent_stack(
            new_agent_name=request.agent_name,
            new_stack_name=new_stack_name,
            model_config=None  # Will read from SSM
        )
        
        logger.info(f"Successfully deployed stack: {result['stack_name']}")
        
        return DeployAgentResponse(
            stack_name=result['stack_name'],
            agent_name=result['agent_name'],
            status=result['status'],
            outputs=result.get('outputs', {}),
            deployed_at=datetime.now().isoformat()
        )
        
    except ValueError as e:
        logger.error("Validation error deploying agent stack")
        log_exception_safely(logger, "Validation error deploying agent stack", e)
        raise HTTPException(status_code=400, detail="Invalid agent deployment parameters")
    except RuntimeError as e:
        logger.error("Runtime error deploying agent stack")
        log_exception_safely(logger, "Runtime error deploying agent stack", e)
        raise HTTPException(status_code=500, detail="Agent stack deployment failed")
    except Exception as e:
        logger.error("Error deploying agent stack")
        log_exception_safely(logger, "Error deploying agent stack", e)
        raise HTTPException(status_code=500, detail="Failed to deploy agent stack")


@deployment_router.get("/stack-status/{agent_name}", response_model=StackStatusResponse)
async def get_stack_status(
    agent_name: str,
    current_user: UserInfo = Depends(get_current_user),
    _: None = Depends(RequirePermission("agent:read")),
    deployment_service: DeploymentService = Depends(get_deployment_service)
):
    """
    Get the current status of an agent's CloudFormation stack.
    
    Args:
        agent_name: Name of the agent
        deployment_service: Injected deployment service
        
    Returns:
        Current stack status and information
        
    Raises:
        HTTPException: If stack not found or error retrieving status
    """
    try:
        logger.info(f"Retrieving status for agent: {agent_name}")
        
        # Find the stack for this agent first
        stack_info = await deployment_service.find_agent_stack_by_name(agent_name)
        
        if not stack_info:
            raise HTTPException(status_code=404, detail="Agent stack not found")
        
        status_info = await deployment_service.get_stack_status(stack_info['stack_name'])
        
        return StackStatusResponse(**status_info)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Error retrieving stack status")
        log_exception_safely(logger, "Error retrieving stack status", e)
        raise HTTPException(status_code=500, detail="Failed to retrieve stack status")


@deployment_router.get("/list-stacks")
async def list_agent_stacks(
    current_user: UserInfo = Depends(get_current_user),
    _: None = Depends(RequirePermission("agent:read")),
    deployment_service: DeploymentService = Depends(get_deployment_service)
):
    """
    List all agent stacks with their current status.
    
    Args:
        deployment_service: Injected deployment service
        
    Returns:
        List of agent stacks with status information
        
    Raises:
        HTTPException: If error retrieving stacks
    """
    try:
        logger.info("Retrieving list of agent stacks")
        
        stacks = await deployment_service.list_agent_stacks()
        
        return {
            "stacks": stacks,
            "count": len(stacks)
        }
        
    except Exception as e:
        logger.error("Error listing agent stacks")
        log_exception_safely(logger, "Error listing agent stacks", e)
        raise HTTPException(status_code=500, detail="Failed to list agent stacks")


@deployment_router.delete("/stack/{agent_name}")
async def delete_agent_stack(
    agent_name: str,
    timeout_minutes: int = 30,
    current_user: UserInfo = Depends(get_current_user),
    _: None = Depends(RequirePermission("agent:delete")),
    deployment_service: DeploymentService = Depends(get_deployment_service)
):
    """
    Delete an agent stack using CloudFormation API.
    
    Args:
        agent_name: Name of the agent
        timeout_minutes: Maximum time to wait for deletion
        deployment_service: Injected deployment service
        
    Returns:
        Deletion confirmation
        
    Raises:
        HTTPException: If stack not found or deletion fails
    """
    try:
        logger.info(f"Deleting stack for agent: {agent_name}")
        
        # Find the stack for this agent first
        stack_info = await deployment_service.find_agent_stack_by_name(agent_name)
        
        if not stack_info:
            raise HTTPException(status_code=404, detail="Agent stack not found")
        
        result = await deployment_service.delete_stack(stack_info['stack_name'])
        
        return {
            "message": f"Stack deletion completed for agent: {agent_name}",
            "stack_name": result['stack_name'],
            "agent_name": agent_name,
            "status": result['status']
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Error deleting stack")
        log_exception_safely(logger, "Error deleting stack", e)
        raise HTTPException(status_code=500, detail="Failed to delete agent stack")


@deployment_router.put("/stack/{agent_name}")
async def update_agent_stack(
    agent_name: str,
    parameters: Dict[str, Any],
    timeout_minutes: int = 30,
    current_user: UserInfo = Depends(get_current_user),
    _: None = Depends(RequirePermission("agent:update")),
    deployment_service: DeploymentService = Depends(get_deployment_service)
):
    """
    Update an existing agent stack using CloudFormation API.
    
    Args:
        agent_name: Name of the agent
        parameters: CloudFormation parameters for update
        timeout_minutes: Maximum time to wait for update
        deployment_service: Injected deployment service
        
    Returns:
        Update confirmation
        
    Raises:
        HTTPException: If stack not found or update fails
    """
    try:
        logger.info(f"Updating stack for agent: {agent_name}")
        
        result = await deployment_service.update_agent_stack(
            agent_name=agent_name,
            parameters=parameters
        )
        
        return {
            "message": f"Stack update completed for agent: {agent_name}",
            "stack_name": result['stack_name'],
            "status": result['status'],
            "outputs": result.get('outputs', {})
        }
        
    except ValueError as e:
        log_exception_safely(logger, e, "Agent stack not found")
        raise HTTPException(status_code=404, detail="Agent stack not found")
    except Exception as e:
        logger.error("Error updating stack")
        log_exception_safely(logger, "Error updating stack", e)
        raise HTTPException(status_code=500, detail="Failed to update agent stack")


@deployment_router.post("/create-agent")
async def create_agent(
    request: Dict[str, Any] = Body(...),
    background_tasks: BackgroundTasks = BackgroundTasks(),
    current_user: UserInfo = Depends(get_current_user),
    _: None = Depends(RequirePermission("agent:deploy")),
    deployment_service: DeploymentService = Depends(get_deployment_service)
):
    """
    Deploy CloudFormation stack for an agent asynchronously.
    
    This endpoint initiates CloudFormation stack creation using DeploymentService
    and returns immediately, preventing health check failures.
    
    The UI workflow is:
    1. UI calls POST /config/save to save agent configuration
    2. UI calls POST /api/deployment/create-agent to initiate deployment (returns immediately)
    3. UI polls GET /api/deployment/stack-status/{agent_name} for progress
    
    Args:
        request: Request body with:
            - new_agent_name: Name of the agent to deploy
        background_tasks: FastAPI background tasks
        deployment_service: Injected deployment service
        
    Returns:
        Immediate response with deployment initiation status
        
    Raises:
        HTTPException: If validation fails or deployment initiation fails
    """
    try:
        # Extract agent name from request
        agent_name = request.get('new_agent_name')
        if not agent_name:
            logger.error(f"new_agent_name not found in request. Available keys: {list(request.keys())}")
            raise HTTPException(status_code=400, detail="new_agent_name is required")
            
        logger.info(f"Initiating CloudFormation stack deployment for agent: {agent_name}")
        
        # Validate agent name format
        if not agent_name.replace('_', '').replace('-', '').isalnum():
            raise HTTPException(
                status_code=400,
                detail="Agent name must contain only letters, numbers, underscores, and hyphens"
            )
        
        # Use consistent naming pattern throughout all operations
        new_stack_name = deployment_service.get_stack_name_from_agent(agent_name)
        
        result = await deployment_service.create_agent_stack(
            new_agent_name=agent_name,
            new_stack_name=new_stack_name,
            model_config=None  # Will read from SSM
        )
        
        logger.info(f"Stack creation initiated for agent: {agent_name}")
        
        return {
            "status": "initiated",
            "message": f"Infrastructure deployment initiated for agent '{agent_name}'",
            "agent_name": agent_name,
            "stack_name": new_stack_name,
            "deployment_status": result['status'],
            "outputs": {},
            "deployed_at": datetime.now().isoformat()
        }
        
    except ValueError as e:
        logger.error("Validation error creating agent")
        log_exception_safely(logger, "Validation error creating agent", e)
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error("Error creating agent")
        log_exception_safely(logger, "Error creating agent", e)
        raise HTTPException(status_code=500, detail="Failed to create agent")


@deployment_router.post("/refresh-agent-urls")
async def refresh_agent_urls(
    current_user: UserInfo = Depends(get_current_user),
    _: None = Depends(RequirePermission("agent:read"))
):
    """
    Trigger supervisor agent to refresh its agent URL cache.
    
    This endpoint is called after agent deployment to ensure the supervisor
    agent has the latest list of available agents and their URLs.
    
    Returns:
        Refresh confirmation
        
    Raises:
        HTTPException: If refresh fails
    """
    try:
        logger.info("Triggering supervisor agent URL cache refresh")
        
        # In a real implementation, this would call the supervisor agent's refresh endpoint
        # For now, return success since the supervisor discovers agents via SSM/VPC Lattice
        
        return {
            "status": "success",
            "message": "Agent URL cache refresh triggered",
            "refreshed_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error("Error refreshing agent URLs")
        log_exception_safely(logger, "Error refreshing agent URLs", e)
        raise HTTPException(status_code=500, detail="Failed to refresh agent URLs")
